require "/scripts/interp.lua"
require "/scripts/vec2.lua"
require "/scripts/rect.lua"

require "/scripts/v-vec2.lua"
require "/scripts/statuseffects/v-tickdamage.lua"

require "/scripts/v-time.lua"

-- Invalidate global height map segments with:
-- /entityeval for x = 0, world.size()[1] // 32 do world.setProperty("v-globalHeightMap." .. x .. ".0", nil) end

local cfg
local unmeltableMaterials

local heatMap
local maxDepth
local minDepth

local burnDepth
local minBurnDamage
local maxBurnDamage
local tickTime

local tickDamage

local heightMap
local affectedTiles

local checkMinX
local checkMaxX
local checkMinY
local checkMaxY

local solidCollisionSet
local collisionSet
local sunLiquidId
local materialConfigs

local sunscreenEffect

local surfaceTileQueryThread
local undergroundTileQueryThread

local ADJACENT_TILES = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}
local SECTOR_SIZE = 32


---@class RawHeightMap
---@field startXPos integer the starting horizontal position
---@field minHeight integer the minimum height to use
---@field list HeightMapItem[] the list of height map values.

---@class HeightMapItem
---@field minValue integer the lowest y value to use
---@field maxValue integer the highest y value to use

---@class HeatedTile
---@field pos Vec2I
---@field heatTolerance number
---@field heat number
---@field heatDeltaDir number

function init()
  -- Do not run this script on planets that are not of type "v-ministar"
  if world.type() ~= "v-ministar" then
    script.setUpdateDelta(0)
    return
  end

  -- script.setUpdateDelta(6)
  script.setUpdateDelta(1)

  cfg = root.assetJson("/v-matattributes.config:ministarHeatConfig")
  unmeltableMaterials = {}
  for _, material in ipairs(cfg.unmeltableMaterials) do
    unmeltableMaterials[material] = true
  end

  ---@type HeatedTile[]
  heatMap = {}
  maxDepth = 1980  -- Depth that heats up the slowest
  minDepth = 1000  -- Depth that heats up the fastest. Also the depth at which the player takes the most burn damage.

  burnDepth = 1500  -- Depth at which the player starts burning
  minBurnDamage = 1
  maxBurnDamage = 20
  tickTime = 0.5

  tickDamage = VTickDamage:new{ kind = "fire", amount = minBurnDamage, damageType = "IgnoresDef", interval = tickTime, source = player.id() }

  heightMap = {list = {}, minHeight = minDepth}
  affectedTiles = {}  -- hash map

  checkMinX = -100
  checkMaxX = 100
  checkMinY = -100
  checkMaxY = 100

  solidCollisionSet = {"Block"}
  collisionSet = {"Block", "Platform"}
  sunLiquidId = 218
  materialConfigs = {}

  sunscreenEffect = "v-sunscreen"

  surfaceTileQueryThread = coroutine.create(surfaceTileQuery)
  undergroundTileQueryThread = coroutine.create(undergroundTileQuery)

  vTime.addInterval(6 / 60, function()
    cleanHeightMap(vec2.floor(mcontroller.position()))
  end)

  vTime.addInterval(1, function()
    for tilePosHash, _ in pairs(affectedTiles) do
      local tilePos = vVec2.iFromString(tilePosHash)

      if world.pointTileCollision(tilePos, {"Null"}) then
        affectedTiles[tilePosHash] = nil
      end
    end
  end)
end

function update(dt)
  local pos = vec2.floor(mcontroller.position())

  coroutine.resume(undergroundTileQueryThread, pos, affectedTiles, dt)

  local success, result = coroutine.resume(surfaceTileQueryThread, pos, affectedTiles, dt)
  if not success then
    error(result)
  end

  -- for i, v in ipairs(result.list) do
  --   world.debugText("%s", v.minValue, {i + result.startXPos, pos[2] + 5 + i % 3}, "red")
  --   world.debugText("%s", v.maxValue, {i + result.startXPos, pos[2] + 7 + i % 3}, "green")
  -- end

  updateHeightMap(result)

  -- for i, v in pairs(heightMap.list) do
  --   xSector = i - 1
  --   for j, v1 in pairs(v) do
  --     local xInSector = j - 1
  --     world.debugPoint({xSector * SECTOR_SIZE + xInSector - 0.25, v1.minValue - 0.25}, "magenta")
  --     world.debugPoint({xSector * SECTOR_SIZE + xInSector - 0.25, v1.maxValue}, "cyan")
  --   end
  -- end
  syncHeightMapToGlobal()

  vTime.update(dt)

  -- for xSector, v in pairs(heightMap.list) do
  --   world.debugText("%s", xSector, {xSector * SECTOR_SIZE, pos[2] - 5}, "yellow")

  --   for i, v1 in pairs(v) do
  --     world.debugText("%s", i, {xSector * SECTOR_SIZE + i, pos[2] - 7}, "orange")
  --     world.debugText("%s", v1.minValue, {xSector * SECTOR_SIZE + i, pos[2] - 13 + i % 3}, "green")
  --     world.debugText("%s", v1.maxValue, {xSector * SECTOR_SIZE + i, pos[2] - 10 + i % 3}, "blue")
  --   end
  -- end
  -- for i, v in pairs(heightMap.list) do
  --   xSector = i - 1
  --   world.debugText("%s", xSector, {xSector * SECTOR_SIZE, pos[2] - 5}, "yellow")
  --   for j, v1 in pairs(v) do
  --     local xInSector = j - 1
  --     local x = xSector * SECTOR_SIZE + xInSector
  --     world.debugText("%s", j, {x, pos[2] - 7 + x % 2}, "orange")
  --     world.debugPoint({xSector * SECTOR_SIZE + xInSector, v1.minValue - 0.25}, "red")
  --     world.debugPoint({xSector * SECTOR_SIZE + xInSector, v1.maxValue}, "blue")
  --     world.debugLine({xSector * SECTOR_SIZE + xInSector, v1.minValue}, {xSector * SECTOR_SIZE + xInSector, v1.maxValue}, "green")
  --   end
  -- end

  -- for tileStr, v in pairs(affectedTiles) do
  --   if v then
  --     local tile = vVec2.iFromString(tileStr)
  --     world.debugPoint(tile, "green")
  --   end
  -- end

  -- Process existing entries.
  local tilesToDestroy = processHeatMap(affectedTiles, dt)

  local sunProximityRatio = 1 - math.max(0, math.min((pos[2] - minDepth) / (maxDepth - minDepth), 1))

  -- Build a JSON-serializable height map.
  local jsonHeightMap = {list = {}, minHeight = minDepth}
  for i, v in pairs(heightMap.list) do
    table.insert(jsonHeightMap.list, {i = i, v = v})
  end
  -- Update heatMap for v-ministareffects.lua
  world.sendEntityMessage(player.id(), "v-ministareffects-updateBlocks", heatMap, jsonHeightMap, sunProximityRatio)

  addToHeatMap(affectedTiles, heightMap, dt)

  local count = 0
  for _,_ in pairs(affectedTiles) do
    count = count + 1
  end
  world.debugText("affectedTiles count: %s, heatMap count: %s", count, #heatMap, {pos[1], pos[2] - 5}, "green")

  -- Destroy tiles.
  world.damageTiles(tilesToDestroy, "foreground", mcontroller.position(), "blockish", 2 ^ 32 - 1, 0)

  -- -- If the player should be burned...
  -- if pos[2] <= burnDepth and isExposedForeground(heightMap) and not status.uniqueStatusEffectActive(sunscreenEffect) then
  --   -- Update damage amount. It is a linear interpolation between maxBurnDamage and minBurnDamage, where damage grows as
  --   -- depth (aka y position) decreases.
  --   tickDamage.damageRequest.damage = interp.linear((pos[2] - minDepth) / (burnDepth - minDepth), maxBurnDamage, minBurnDamage)
  --   tickDamage:update(dt)  -- Run the tickDamage object for one tick.
  -- else
  --   tickDamage:reset()
  -- end
end

-- ---Populates `affectedTiles` with a list of tiles that are exposed to the surface below given a central position `pos`.
-- ---@param pos Vec2I
-- ---@param affectedTiles table<string, boolean>
-- ---@return RawHeightMap
-- function surfaceTileQuery(pos, affectedTiles)
--   -- Maps horizontal positions relative to startXPos to collision heights.
--   local heightMap = {startXPos = checkMinX + pos[1], list = {}, minHeight = minDepth}

--   local lowestSectors = findLowestLoadedSectors(checkMinX + pos[1], checkMaxX + pos[1], pos[2])

--   -- Convert lowestSectors into a horizontal position map.
--   local lowestSectorsMap = {}

--   for _, sector in ipairs(lowestSectors) do
--     local checkMinY = (sector[2] + 1) * SECTOR_SIZE
--     -- Variant of checkMinY that stops at minDepth; whether or not the value was capped.
--     local cappedCheckMinY, checkMinYWasCapped
--     if checkMinY < minDepth then
--       cappedCheckMinY = minDepth
--       checkMinYWasCapped = true
--     else
--       cappedCheckMinY = checkMinY
--       checkMinYWasCapped = false
--     end
--     lowestSectorsMap[sector[1]] = {y = cappedCheckMinY, capped = checkMinYWasCapped}
--   end

--   -- Generate a set of tiles that are heated right now.
--   for i = checkMinX, checkMaxX do
--     local x = i + pos[1]
--     -- Find associated lowest sector.
--     local xSector = x // SECTOR_SIZE
--     local sectorValue = lowestSectorsMap[xSector]
--     local cappedCheckMinY = sectorValue.y
--     local checkMinYWasCapped = sectorValue.capped

--     -- Proceed only if cappedCheckMinY is not actually capped or there is a liquid with ID sunLiquidId at the position
--     -- directly below cappedCheckMinY.
--     local shouldProceed = not checkMinYWasCapped
--     if checkMinYWasCapped then
--       local liquid = world.liquidAt({x, cappedCheckMinY - 1})
--       if liquid and liquid[1] == sunLiquidId then
--         shouldProceed = true
--       end
--     end

--     if shouldProceed then
--       local collidePoints = world.collisionBlocksAlongLine({x, cappedCheckMinY}, {x, checkMaxY + pos[2]}, collisionSet, 20)

--       -- Mark all tiles as affected. Stop after reaching the first solid, opaque tile.
--       local foundSolidTile = false
--       for _, collideTile in ipairs(collidePoints) do
--         local collideTileStr = vVec2.iToString(collideTile)
--         affectedTiles[collideTileStr] = true

--         local material = world.material(collideTile, "foreground")
--         if material then
--           local matCfg = getMaterialConfig(material)
--           if matCfg and not matCfg.renderParameters.lightTransparent and matCfg.collisionKind == "solid" then
--             -- Add to height map.
--             heightMap.list[i - checkMinX + 1] = {minValue = cappedCheckMinY, maxValue = collideTile[2]}
--             foundSolidTile = true
--             break
--           end
--         end
--       end

--       -- Manually set the heightMap entry if no solid, opaque tile was found, or collidePoints is empty.
--       if not foundSolidTile then
--         heightMap.list[i - checkMinX + 1] = {minValue = cappedCheckMinY, maxValue = checkMaxY + pos[2]}
--       end
--     else
--       heightMap.list[i - checkMinX + 1] = {minValue = cappedCheckMinY, maxValue = cappedCheckMinY}
--     end
--   end

--   return heightMap
-- end

---Coroutine. Populates `affectedTiles` with a list of tiles that are exposed to the surface below given a central
---position `pos`.
---@param pos Vec2I
---@param dt number
---@return RawHeightMap
function surfaceTileQuery(pos, affectedTiles, dt)
  local heightMapChunk = {list = {}, startXPos = checkMinX + pos[1]}  -- A chunk of the height map.
  local startTime = os.clock()
  local i = 1  -- Next index to use for inserting into heightMapChunk. equiv to #heightMapChunk + 1

  local passes = 0

  while true do  -- Repeat indefinitely
    -- Convert lowestSectors into a horizontal position map.
    local lowestSectorsMap = {}

    for relX = checkMinX, checkMaxX do
      local x = relX + pos[1]

      if not lowestSectorsMap[x // SECTOR_SIZE] then
        local lowestSectors = findLowestLoadedSectors(checkMinX + pos[1], checkMaxX + pos[1], pos[2])
        for _, sector in ipairs(lowestSectors) do
          local checkMinY = (sector[2] + 1) * SECTOR_SIZE
          -- Variant of checkMinY that stops at minDepth; whether or not the value was capped.
          local cappedCheckMinY, checkMinYWasCapped
          if checkMinY < minDepth then
            cappedCheckMinY = minDepth
            checkMinYWasCapped = true
          else
            cappedCheckMinY = checkMinY
            checkMinYWasCapped = false
          end
          lowestSectorsMap[sector[1]] = {y = cappedCheckMinY, capped = checkMinYWasCapped}
        end
      end

      world.debugPoint({x, pos[2]}, "red")
      -- Find associated lowest sector.
      local xSector = x // SECTOR_SIZE
      local sectorValue = lowestSectorsMap[xSector]
      local cappedCheckMinY = sectorValue.y
      local checkMinYWasCapped = sectorValue.capped

      -- Proceed only if cappedCheckMinY is not actually capped or there is a liquid with ID sunLiquidId at the position
      -- directly below cappedCheckMinY.
      local shouldProceed = not checkMinYWasCapped
      if checkMinYWasCapped then
        local liquid = world.liquidAt({x, cappedCheckMinY - 1})
        if liquid and liquid[1] == sunLiquidId then
          shouldProceed = true
        end
      end
      local heightMapValue

      if shouldProceed then
        local collisionPoints = world.collisionBlocksAlongLine({x, cappedCheckMinY}, {x, checkMaxY + pos[2]}, collisionSet)

        -- Mark all tiles as affected. Stop after reaching the first solid, opaque tile.
        local foundSolidTile = false
        for _, collideTile in ipairs(collisionPoints) do
          local collideTileStr = vVec2.iToString(collideTile)

          local material = world.material(collideTile, "foreground")
          if material then
            if not unmeltableMaterials[material] then
              affectedTiles[collideTileStr] = material
            end
            local matCfg = getMaterialConfig(material)

            if matCfg and not matCfg.renderParameters.lightTransparent and matCfg.collisionKind == "solid" then
              -- Add to height map.
              heightMapValue = {minValue = cappedCheckMinY, maxValue = collideTile[2]}
              foundSolidTile = true
              break
            end
          end
        end

        -- Manually set the heightMap entry if no solid, opaque tile was found, or collidePoints is empty.
        if not foundSolidTile then
          heightMapValue = {minValue = cappedCheckMinY, maxValue = checkMaxY + pos[2]}
        end
      else
        heightMapValue = {minValue = cappedCheckMinY, maxValue = cappedCheckMinY}
      end

      heightMapChunk.list[i] = heightMapValue
      i = i + 1

      if os.clock() - startTime > dt * 0.000001 then
        -- Give back heightMapChunk and affectedTiles; get fresh pos and dt.
        pos, affectedTiles, dt = coroutine.yield(heightMapChunk)
        -- Reset variables
        heightMapChunk.list = {}
        heightMapChunk.startXPos = relX + pos[1] + 1
        i = 1
        startTime = os.clock()
      end
    end

    passes = passes + 1

    -- sb.logInfo("passes so far: %s", passes)

    -- Give back heightMapChunk and affectedTiles; get fresh pos and dt.
    pos, affectedTiles, dt = coroutine.yield(heightMapChunk)
    -- Reset variables
    heightMapChunk.list = {}
    heightMapChunk.startXPos = checkMinX + pos[1]
    startTime = os.clock()
  end
end

function updateHeightMap(heightMapChunk)
  -- Split the heightMapChunk by sector and put it into heightMap.
  for i, v in ipairs(heightMapChunk.list) do
    local x = world.xwrap(i + heightMapChunk.startXPos - 1)
    -- world.debugLine({x, v.minValue}, {x, v.maxValue}, "white")
    local xSector = x // SECTOR_SIZE + 1
    local xInSector = x % SECTOR_SIZE + 1
    if not heightMap.list[xSector] then
      heightMap.list[xSector] = {}
    end
    heightMap.list[xSector][xInSector] = v
  end
  -- for k, v in pairs(heightMap.list) do
  --   sb.logInfo("%s:", k)
  --   for k1, v1 in pairs(v) do
  --     sb.logInfo("  %s: %s", k1, v1)
  --   end
  -- end
end

function cleanHeightMap(pos)
  -- Clean up unused entries
  for i, _ in pairs(heightMap.list) do
    local xSectorCoord = (i - 1) * SECTOR_SIZE
    if pos[1] + checkMinX * 2 > xSectorCoord or xSectorCoord > pos[1] + checkMaxX * 2 then
      heightMap.list[i] = nil
    end
  end
end

-- function syncHeightMapToGlobal(heightMap)
--   local startXSector = heightMap.startXPos // SECTOR_SIZE
--   local endXSector = (heightMap.startXPos + #heightMap.list) // SECTOR_SIZE

--   -- Map from horizontal positions to `HeightMapItem`.
--   ---@type table<integer, HeightMapItem>
--   local globalHeightMap = {}
--   -- For each `xSector` from `startXSector` to `endXSector`...
--   for xSector = startXSector, endXSector do
--     local xSectorWrapped = world.xwrap(xSector * SECTOR_SIZE) // SECTOR_SIZE
--     -- Get global height map section corresponding to `xSector`.
--     local globalHeightMapSection = world.getProperty("v-globalHeightMap." .. xSectorWrapped) or {}

--     -- Copy the section over to globalHeightMap.
--     for _, value in ipairs(globalHeightMapSection) do
--       globalHeightMap[value.x] = value.value
--     end
--   end

--   -- For each entry in the list of `heightMap`...
--   for i, v in ipairs(heightMap.list) do
--     local x = world.xwrap(i + heightMap.startXPos - 1)

--     if not globalHeightMap[x] then
--       globalHeightMap[x] = v
--     else
--       local globalV = globalHeightMap[x]

--       local sharedValue = {
--         minValue = math.min(globalV.minValue, v.minValue),
--         maxValue = true  -- Placeholder value to avoid rehashing.
--       }
--       if v.maxValue < globalV.maxValue or not world.pointCollision({x, globalV.maxValue}, {"Null"}) then
--         sharedValue.maxValue = v.maxValue
--       else
--         sharedValue.maxValue = globalV.maxValue
--       end

--       heightMap.list[i] = sharedValue
--       globalHeightMap[x] = sharedValue
--     end
--   end

--   -- Store globalHeightMap sections.
--   -- For each `xSector` from `startXSector` to `endXSector`...
--   for xSector = startXSector, endXSector do
--     local globalHeightMapSection = {}
--     local xSectorWrapped = world.xwrap(xSector * SECTOR_SIZE) // SECTOR_SIZE

--     -- For each x value in the sector...
--     for x = xSectorWrapped * SECTOR_SIZE, (xSectorWrapped + 1) * SECTOR_SIZE - 1 do
--       -- Add to the section.
--       table.insert(globalHeightMapSection, {x = x, value = globalHeightMap[x]})
--     end

--     world.setProperty("v-globalHeightMap." .. xSectorWrapped, globalHeightMapSection)
--   end
--

function syncHeightMapToGlobal()
  for i, sectorHeightMap in pairs(heightMap.list) do
    local xSector = i - 1
    -- Look up corresponding section of global height map.
    local globalHeightMapSection = world.getProperty("v-globalHeightMap." .. xSector) or {}

    -- Convert to index map (short for "global height section index map").
    local gHSIdxMap = {}
    for _, value in pairs(globalHeightMapSection) do
      -- -- Backwards compatibility check.
      -- if value.x then
      --   value.i = value.x - xSector + 1
      -- end

      gHSIdxMap[value.i] = value.value
    end

    for j, v in pairs(sectorHeightMap) do
      if not gHSIdxMap[j] then
        gHSIdxMap[j] = v
      else
        local x = world.xwrap(j + xSector * SECTOR_SIZE - 1)
        local globalV = gHSIdxMap[j]

        local sharedValue = {
          minValue = math.min(v.minValue, globalV.minValue),
          maxValue = true  -- Placeholder value to avoid rehashing.
        }
        if v.maxValue < globalV.maxValue or not world.pointTileCollision({x, globalV.maxValue}, {"Null"}) then
          sharedValue.maxValue = v.maxValue
        else
          sharedValue.maxValue = globalV.maxValue
        end
        -- sharedValue = v

        sectorHeightMap[j] = sharedValue
        gHSIdxMap[j] = sharedValue
      end
    end

    -- Update globalHeightMapSection.
    globalHeightMapSection = {}
    for j, v in pairs(gHSIdxMap) do
      table.insert(globalHeightMapSection, {i = j, value = v})
    end
    world.setProperty("v-globalHeightMap." .. xSector, globalHeightMapSection)
  end
end

---Coroutine function. Fills `affectedTiles` with tiles that are directly adjacent to spaces occupied by the liquid with
---ID `sunLiquidId`.
---@param pos Vec2I
---@param affectedTiles table<string, boolean>
---@param dt number
function undergroundTileQuery(pos, affectedTiles, dt)
  local rollingAffectedTiles = {}  -- Maintained map of affected tiles.

  local updateAffectedTiles = function(affectedTiles)
    -- Update affectedTiles with rollingAffectedTiles.
    for tilePosHash, mat in pairs(rollingAffectedTiles) do
      if not unmeltableMaterials[mat] then
        affectedTiles[tilePosHash] = mat
      end
    end
  end
  -- Queries tiles that are next to entries in rollingAffectedTiles that no longer exist.
  local hotTileQuery = function()
    local startTime = os.clock()  -- Record start time.
    -- Store list of additions because adding to rollingAffectedTiles directly while looping over rollingAffectedTiles
    -- is not recommended.
    local rollingAffectedTilesAdditions = {}
    -- For each tile in rollingAffectedTiles...
    for tilePosHash, _ in pairs(rollingAffectedTiles) do
      local tilePos = vVec2.iFromString(tilePosHash)

      if not world.pointTileCollision(tilePos, collisionSet) then
        rollingAffectedTiles[tilePosHash] = nil  -- Clear the entry.

        -- For each adjacent tile...
        for _, offset in ipairs(ADJACENT_TILES) do
          local offsetTilePos = vec2.add(tilePos, offset)

          local mat = world.material(offsetTilePos, "foreground")

          -- If the tile is solid and is adjacent to sun liquid...
          if mat and isAdjacentToSunLiquid(offsetTilePos) then
            -- Add entry to additions.
            rollingAffectedTilesAdditions[vVec2.iToString(offsetTilePos)] = mat
          end
        end
      end
    end

    -- Merge additions into rollingAffectedTiles.
    for tilePosHash, mat in pairs(rollingAffectedTilesAdditions) do
      rollingAffectedTiles[tilePosHash] = mat
    end

    -- Halt for one tick if too much time has passed.
    if os.clock() - startTime > dt * 0.0001 then
      updateAffectedTiles(affectedTiles)
      pos, affectedTiles, dt = coroutine.yield()  -- Halt for the current frame and update the arguments.
      cappedCheckMaxY = math.min(checkMaxY + pos[2], minDepth) -- Update cappedCheckMinY
    end
  end

  -- Repeat indefinitely.
  while true do
    local cappedCheckMaxY = math.min(checkMaxY + pos[2], minDepth)

    -- For each horizontal strip...
    for x = checkMinX, checkMaxX do
      hotTileQuery()
      local startTime = os.clock()  -- Record start time.
      local absX = x + pos[1]  -- Get x in world coordinates.
      -- For each vertical position...
      for y = checkMinY + pos[2], cappedCheckMaxY do
        local tilePos = {absX, y}
        -- If there is a tile and it is adjacent to sun liquid, then add the corresponding entry to true. Otherwise,
        -- delete it.
        local mat = world.material(tilePos, "foreground")
        if mat and isAdjacentToSunLiquid(tilePos) then
          rollingAffectedTiles[vVec2.iToString(tilePos)] = mat
        else
          rollingAffectedTiles[vVec2.iToString(tilePos)] = nil
        end
      end
      -- If the time elapsed exceeds dt * 0.0000001...
      if os.clock() - startTime > dt * 0.0001 then
        updateAffectedTiles(affectedTiles)
        pos, affectedTiles, dt = coroutine.yield()  -- Halt for the current frame and update the arguments.
        cappedCheckMaxY = math.min(checkMaxY + pos[2], minDepth) -- Update cappedCheckMinY
      end
    end

    updateAffectedTiles(affectedTiles)
    pos, affectedTiles, dt = coroutine.yield()  -- Update the arguments
  end
end

---Given a hash set of `affectedTiles`, updates `heatMap`. Each entry in `heatMap` that is also present in
---`affectedTiles` has its heat increased (decreased otherwise). Returns a list of tiles to destroy. Note: This also
---updates `affectedTiles` to exclude what was found in `heatMap`.
---@param affectedTiles table<string, boolean>
---@param dt number
---@return Vec2I[]
function processHeatMap(affectedTiles, dt)
  local tilesToDestroy = {}
  -- For each tile in the heatMap (iterated through backwards)...
  for i = #heatMap, 1, -1 do
    local tile = heatMap[i]

    local tilePosHash = vVec2.iToString(tile.pos)

    -- If the tile is in affectedTiles...
    if affectedTiles[tilePosHash] then
      tile.heat = tile.heat + dt
      tile.heatDeltaDir = 1

      if tile.heat > tile.heatTolerance then
        table.insert(tilesToDestroy, tile.pos)
        table.remove(heatMap, i)

        -- Remove entry from affectedTiles to avoid excess inserts.
        affectedTiles[tilePosHash] = nil
      end
    -- Otherwise, if the tile no longer exists...
    elseif not world.pointTileCollision(tile.pos, collisionSet) then
      table.remove(heatMap, i)
    else
      tile.heat = tile.heat - dt
      tile.heatDeltaDir = -1

      if tile.heat <= 0 then
        table.remove(heatMap, i)
      end
    end
  end

  return tilesToDestroy
end

---Adds `affectedTiles` to `heatMap` that are below the `maxDepth` value and are meltable.
---
---Note: This also clears entries of affectedTiles where appropriate.
---
---@param affectedTiles table<string, string>
---@param heightMap RawHeightMap
---@param dt number
function addToHeatMap(affectedTiles, heightMap, dt)
  -- For each tile in `affectedTiles`...
  for tileHash, material in pairs(affectedTiles) do
    local tile = vVec2.iFromString(tileHash)

    local xSector = tile[1] // SECTOR_SIZE
    local xInSector = tile[1] % SECTOR_SIZE

    -- world.debugText("%s", xSector, tile, "green")
    -- world.debugText("%s", xInSector, {tile[1], tile[2] + 1 + tile[1] % 2}, "blue")
    local isExposed  -- Whether or not the affected tile is exposed (and therefore should be burned).
    local heightMapSectorValue = heightMap.list[xSector + 1]
    if heightMapSectorValue then
      local heightMapValue = heightMapSectorValue[xInSector + 1]
      if heightMapValue then
        isExposed = tile[2] <= heightMapValue.maxValue
      else
        isExposed = false
        -- sb.logInfo("heightMap.list[%s][%s]: Not defined", xSector + 1, xInSector + 1)
      end
    else
      isExposed = false
      -- sb.logInfo("heightMap.list[%s]: Not defined", xSector + 1)
    end

    -- If there is a material at this tile and it is exposed...
    if material and isExposed then
      -- Compute tolerance multiplier (tiles that are closer to minDepth have a lower heat tolerance). Capped at 0.
      local toleranceMultiplier = math.max(0, (tile[2] - minDepth) / (maxDepth - minDepth))

      -- If the tolerance multiplier is at most 1...
      if toleranceMultiplier <= 1.0 then
        local matCfg = getMaterialConfig(material)
        local tileConfig = cfg.tileConfigs[material]
        local toleranceOffset = 0
        if tileConfig and tileConfig.toleranceOffset then
          toleranceOffset = tileConfig.toleranceOffset
        end
        local baseTolerance
        if matCfg then
          baseTolerance = matCfg.falling and cfg.fallingTileDefaultTolerance or cfg.defaultTolerance
        else
          baseTolerance = cfg.defaultTolerance
        end
        local tolerance = baseTolerance * toleranceMultiplier + toleranceOffset
        table.insert(heatMap, {pos = tile, heat = 0, heatTolerance = tolerance > dt and tolerance or 0, heatDeltaDir = 1})
      end
    end
  end
end

---Returns whether or not the player is exposed to the sunlight below provided a `heightMap`.
---@param heightMap RawHeightMap
---@return boolean
function isExposedForeground(heightMap)
  local pos = mcontroller.position()
  local boundBox = rect.translate(mcontroller.boundBox(), pos)
  local y = pos[2]

  -- For each x across the current bounding box...
  for x = boundBox[1], boundBox[3] do
    local xSector = x // SECTOR_SIZE
    local xInSector = x % SECTOR_SIZE
    local heightMapChunkItem = heightMap.list[xSector]

    if not heightMapChunkItem then
      return false
    end

    local heightMapItem = heightMapChunkItem[xInSector]

    if not heightMapItem then
      return false
    end

    -- If the height map's maxValue is greater than y...
    if heightMapItem.maxValue > y then
      return true
    end
  end

  return false
end

---Returns whether or not the given position `pos` is adjacent to a liquid with ID `sunLiquidId`.
---@param pos Vec2I
function isAdjacentToSunLiquid(pos)
  -- For each adjacent tile...
  for _, offset in ipairs(ADJACENT_TILES) do
    local liquid = world.liquidAt(vec2.add(pos, offset))  -- Get the liquid at that position.
    -- If a liquid is present and its ID is `sunLiquidId`...
    if liquid and liquid[1] == sunLiquidId then
      return true
    end
  end

  return false
end

---Returns a list of the lowest sectors loaded between `xStart` and `xEnd`, starting at `yStart`.
---@param xStart number
---@param xEnd number
---@param yStart number
---@return Vec2I[]
function findLowestLoadedSectors(xStart, xEnd, yStart)
  local xSectorStart = xStart // SECTOR_SIZE
  local xSectorEnd = xEnd // SECTOR_SIZE
  local ySectorStart = yStart // SECTOR_SIZE

  local lowestSectors = {}

  -- For each column of sectors intersecting the area between xStart and xEnd...
  for xSector = xSectorStart, xSectorEnd do
    local ySector = ySectorStart
    -- While the current sector is loaded...
    -- while world.material({xSector * SECTOR_SIZE, ySector * SECTOR_SIZE}, "foreground") ~= nil do
    while not world.pointCollision({xSector * SECTOR_SIZE, ySector * SECTOR_SIZE}, {"Null"}) do
      ySector = ySector - 1
    end

    -- Add result to lowestSectors
    table.insert(lowestSectors, {xSector, ySector})
  end

  return lowestSectors
end

---Gets the material config, caching what is relevant if it is not already cached.
---@param material string
---@return Json?
function getMaterialConfig(material)
  -- Register material if it is valid and is not already registered.
  if not materialConfigs[material] then
    local matConfigAndPath = root.materialConfig(material)
    if matConfigAndPath then
      local matConfig = matConfigAndPath.config
      materialConfigs[material] = {
        falling = matConfig.falling,
        renderParameters = matConfig.renderParameters,
        collisionKind = matConfig.collisionKind or "solid"
      }
    end
  end

  return materialConfigs[material]
end